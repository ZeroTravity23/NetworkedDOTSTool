# DOTS-Tool
<h1>About</h1>
<p>This project attempts to refine the current [FPSSample](https://github.com/Unity-Technologies/FPSSample) and [DOTSSample](https://github.com/Unity-Technologies/DOTSSample) projects, which provide tools and guidance for developing networked games on the new DOTS architecture, into a lightweight version. Having used these tools previously and by researching Unity forums, I have identified a strong need for a lightwieght DOTS tool in the game development community. The current tools consist of Unity projects with fully functional examples that make them bulky and difficult to work with. These included examples increase build times and make testing difficult. Consequently, these tools are not efficient and are of little use to developers new to the DOTS architecture. This refined tool utilizes scriptable objects and a custom editor to generate the scripts necessary for ECS implementation. This allows users to more readily transition from object oriented programming to data oriented programming. Users may wish to continue using these scriptable objects to build their ECS scripts or inspect the generated scripts to get a better understanding of their structure for transitioning away from the tool. Ultimately, I hope users can come away from using this tool with a stronger understanding of DOTS ECS implementation in Unity and applying it, where applicable, to their projects.
</p>

<h1>DOTS & ECS</h1>
<p>The Data Oriented Technology Stack (DOTS) and the Entity Component System (ECS) drastically increases the performance of games developed in Unity. This performance boost permits for stable and reliable network communications necessary for immersive and consistent networked gameplay. DOTS is comprised of three major components: the C# Job System, ECS, and a burst compiler. These in conjunction allow for processes to be split across multiple threads as opposed to them all running on the main thread. DOTS is not applicable to everything, and MonoBehaviors are not being deprecated. However, DOTS is the preferred architecture for systems that are extremely intensive such as instantiating thousands of objects and managing networked items. This project focuses on the ECS elements, as this is where the code implementation truly changes. The C# Job System and burst compiler can be obtained via installing Microsoft's Visual Studio and utilizing their features is simply a matter of enabling them.</p>
<h2>Entities</h2>
<p>The entities are essentially lightweight GameObjects without any data that serve as placeholders or IDâ€™s that components are assigned to. At first they may seem foreign as they have no components, not even a Transform, like that of an empty GameObject. This reduction allows for more compact storage in memory so that systems can easily identify the components and entities to act upon.</p>
<h2>Components</h2>
<p>The components are the actual variables that hold data. While we are currently accustomed to putting variables and logic scripts all on a singular GameObject, this is an inefficient means of storing the data in memory and leads to unoptimized applications. Therefore, only Components are associated with Entities, not the System scripts.</p>
<h2>Systems</h2>
<p>Systems identify specified Components and act upon them. If you have multiple entities with a health Component, and you create a system to slowly regenerate it over time, every Entity with this component will have their health regenerated. One system can be created to update every single Component, and they do not get assigned to individual game objects. These scripts simply live in your project and utilize the job system to schedule their processes across all threads (if specified to do so) to increase efficiency. Updating the health of a thousand enemies in one scene could kill your framerate if you utilized the GameObject approach each with their own individual script.</p>
<h2>Pure ECS vs. Hybrid ECS</h2>
<p>Game development is uniquely visual and we have become extremely familiar with the GameObject approach to development. However, when implementing ECS, there is no need for GameObjects that represent your players or objects in the game world. Instead, Entities get instantiated at the start of playing the scene. This strict implementation of ECS without GameObjects is commonly referred to as 'Pure ECS.' Pure ECS has its applications, particularly when you're instantiating thousands of entities that you would never want to manually place.  However, this would make development extremely difficult if you couldn't visualize the scene you're developing. Consequently, Unity has been working on their Entity Conversion system. This system allows for either the use of Subscenes or Convert components to transition exisiting GameObjects into Entities with their associated Components. This conversion of GameObjects to Entities and Components is considered 'Hybrid ECS.' The conversion is not perfect, but most basic properties of a GameObject can be converted into a Component (i.e., Mesh, MeshRenderer, Translation, RigidBody, Physics, etc.). Additionally, custom Component scripts can be applied to GameObjects that your System scripts will act upon, allowing you to take full advantage of both GameObjects for visualization and ECS for optimization </p>
<p>This tool permits for both Pure and Hybrid ECS implementations. However, it is important to note that NetCode (the DOTS implementation of Networking) requires the hybrid approach.</p>
<h1>How To Use</h1>
<h2>Requirements</h2>


